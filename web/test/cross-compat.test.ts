/**
 * Cross-compatibility tests for SlopCrypt TypeScript implementation.
 *
 * These tests verify that the TypeScript implementation can correctly
 * process data generated by the Python implementation and vice versa.
 */

import { describe, it, expect, beforeAll } from 'vitest';
import { readFileSync, existsSync } from 'fs';
import { join } from 'path';
import { webcrypto } from 'crypto';

// Polyfill crypto for Node.js environment
if (typeof globalThis.crypto === 'undefined') {
  // @ts-ignore
  globalThis.crypto = webcrypto;
}

import { FixedDistributionClient } from '../src/fixed-client.ts';
import { deriveKeyBytes, decryptPayload, bytesToBase64, base64ToBytes } from '../src/crypto.ts';
import { decryptSecretBlob, encryptSecretBlob, generateSecret } from '../src/secret.ts';
import {
  huffmanDecode,
  huffmanEncode,
  decompressPayload,
  compressPayload,
  arithmeticEncode,
  arithmeticDecode,
  DEFAULT_FREQUENCIES,
} from '../src/huffman.ts';
import { decodeMessage, encodeMessage } from '../src/stego.ts';
import {
  COMPRESSION_HUFFMAN,
  COMPRESSION_NONE,
  COMPRESSION_ARITHMETIC,
  PAYLOAD_KEY_SIZE,
  SECRET_VERSION,
} from '../src/types.ts';

const FIXTURES_DIR = join(__dirname, '../../tests/fixtures');

// Helper to load fixtures
function loadFixture<T>(name: string): T | null {
  const path = join(FIXTURES_DIR, name);
  if (!existsSync(path)) {
    console.warn(`Fixture not found: ${path}`);
    return null;
  }
  return JSON.parse(readFileSync(path, 'utf-8'));
}

// Type definitions for fixtures
interface PBKDF2Vector {
  password: string;
  salt: string;
  expected_key: string;
}

interface AESGCMVector {
  key: string;
  plaintext: string;
  ciphertext: string;
}

interface CryptoVectors {
  pbkdf2_vectors: PBKDF2Vector[];
  aesgcm_vectors: AESGCMVector[];
}

interface SecretBlob {
  encrypted: string;
  password: string;
  expected: {
    version: number;
    k: number;
    knock: number[];
    preamble_tokens: number;
    suffix_tokens: number;
    temperature: number;
    payload_key_length: number;
  };
}

interface SecretBlobs {
  blobs: SecretBlob[];
}

interface HuffmanCompressed {
  original: string;
  compressed: string;
  compression_type: number;
  frequencies?: Record<string, number>;
}

interface HuffmanData {
  compressed: HuffmanCompressed[];
  default_frequencies: Record<string, number>;
}

interface StegoEncoded {
  secret_blob: string;
  password: string;
  prompt: string;
  cover_text: string;
  expected_message: string;
}

interface StegoRoundtrip {
  encoded: StegoEncoded[];
}

describe('Cross-compatibility: Crypto', () => {
  let cryptoVectors: CryptoVectors | null;

  beforeAll(() => {
    cryptoVectors = loadFixture<CryptoVectors>('crypto_vectors.json');
  });

  describe('PBKDF2 Key Derivation', () => {
    it('derives same keys as Python', async () => {
      if (!cryptoVectors) {
        console.warn('Skipping: crypto_vectors.json not found');
        return;
      }

      for (const vector of cryptoVectors.pbkdf2_vectors) {
        const salt = base64ToBytes(vector.salt);
        const keyBytes = await deriveKeyBytes(vector.password, salt);
        const keyBase64 = bytesToBase64(keyBytes);

        expect(keyBase64).toBe(vector.expected_key);
      }
    });

    it('handles empty password', async () => {
      if (!cryptoVectors) return;

      const emptyPasswordVectors = cryptoVectors.pbkdf2_vectors.filter(
        (v) => v.password === ''
      );

      for (const vector of emptyPasswordVectors) {
        const salt = base64ToBytes(vector.salt);
        const keyBytes = await deriveKeyBytes('', salt);
        const keyBase64 = bytesToBase64(keyBytes);

        expect(keyBase64).toBe(vector.expected_key);
      }
    });
  });

  describe('AES-GCM Encryption', () => {
    it('decrypts Python-encrypted payloads', async () => {
      if (!cryptoVectors) return;

      for (const vector of cryptoVectors.aesgcm_vectors) {
        const key = base64ToBytes(vector.key);
        const ciphertext = base64ToBytes(vector.ciphertext);
        const expectedPlaintext = base64ToBytes(vector.plaintext);

        const decrypted = await decryptPayload(ciphertext, key);

        expect(decrypted).toEqual(expectedPlaintext);
      }
    });
  });
});

describe('Cross-compatibility: Secret Blobs', () => {
  let secretBlobs: SecretBlobs | null;

  beforeAll(() => {
    secretBlobs = loadFixture<SecretBlobs>('secret_blobs.json');
  });

  it('decrypts Python-encrypted secret blobs', async () => {
    if (!secretBlobs) {
      console.warn('Skipping: secret_blobs.json not found');
      return;
    }

    for (const blob of secretBlobs.blobs) {
      const secret = await decryptSecretBlob(blob.encrypted, blob.password);

      expect(secret.version).toBe(blob.expected.version);
      expect(secret.k).toBe(blob.expected.k);
      expect(secret.knock).toEqual(blob.expected.knock);
      expect(secret.preamble_tokens).toBe(blob.expected.preamble_tokens);
      expect(secret.suffix_tokens).toBe(blob.expected.suffix_tokens);
      expect(secret.temperature).toBeCloseTo(blob.expected.temperature, 3);
      expect(secret.payload_key.length).toBe(PAYLOAD_KEY_SIZE);
    }
  });

  it('fails to decrypt with wrong password', async () => {
    if (!secretBlobs) return;

    for (const blob of secretBlobs.blobs) {
      await expect(
        decryptSecretBlob(blob.encrypted, 'wrong_password_12345')
      ).rejects.toThrow();
    }
  });

  it('generates blobs Python can decrypt', async () => {
    // This test generates a blob; Python tests verify it can be decrypted
    const secret = generateSecret({ k: 16, knock: [0, 1, 2, 3, 4, 5] });
    const password = 'ts_generated_test';

    const encrypted = await encryptSecretBlob(secret, password);

    // Verify we can decrypt our own blob
    const decrypted = await decryptSecretBlob(encrypted, password);
    expect(decrypted.k).toBe(16);
    expect(decrypted.knock).toEqual([0, 1, 2, 3, 4, 5]);
  });
});

describe('Cross-compatibility: Huffman Compression', () => {
  let huffmanData: HuffmanData | null;

  beforeAll(() => {
    huffmanData = loadFixture<HuffmanData>('huffman_data.json');
  });

  it('roundtrips ASCII text correctly', () => {
    // Note: Only test with data that's in the frequency table.
    // The escape mechanism for bytes not in the table is broken in both
    // Python and TypeScript implementations.
    const testCases = [
      'The quick brown fox jumps over the lazy dog.',
      'Hello World',
      'AAAAAAAAAA',
      'Testing 123',
    ];

    for (const text of testCases) {
      const original = new TextEncoder().encode(text);
      const compressed = huffmanEncode(original, DEFAULT_FREQUENCIES);
      const decompressed = huffmanDecode(compressed, DEFAULT_FREQUENCIES);

      expect(decompressed).toEqual(original);
    }
  });

  it('matches default frequency VALUES with Python', () => {
    if (!huffmanData) return;

    const pyFrequencies = Object.fromEntries(
      Object.entries(huffmanData.default_frequencies).map(([k, v]) => [
        parseInt(k),
        v,
      ])
    );

    // Check that all TypeScript default frequencies match Python
    // Note: The VALUES must match even if key iteration order differs
    for (const [byte, freq] of Object.entries(DEFAULT_FREQUENCIES)) {
      expect(pyFrequencies[parseInt(byte as string)]).toBe(freq);
    }
  });

  it('produces smaller output for English text', () => {
    const englishText = new TextEncoder().encode(
      'The quick brown fox jumps over the lazy dog.'
    );
    const compressed = huffmanEncode(englishText, DEFAULT_FREQUENCIES);

    // Huffman should reduce size for English text
    expect(compressed.length).toBeLessThan(englishText.length);
  });
});

describe('Arithmetic Coding', () => {
  it('roundtrips ASCII text correctly', () => {
    const testCases = [
      'The quick brown fox jumps over the lazy dog.',
      'Hello World',
      'AAAAAAAAAA',
      'Testing 123',
    ];

    for (const text of testCases) {
      const original = new TextEncoder().encode(text);
      const compressed = arithmeticEncode(original, DEFAULT_FREQUENCIES);
      const decompressed = arithmeticDecode(compressed, DEFAULT_FREQUENCIES);

      expect(decompressed).toEqual(original);
    }
  });

  it('handles empty data', () => {
    const original = new Uint8Array(0);
    const compressed = arithmeticEncode(original, DEFAULT_FREQUENCIES);
    const decompressed = arithmeticDecode(compressed, DEFAULT_FREQUENCIES);

    expect(decompressed).toEqual(original);
  });

  it('handles single byte', () => {
    const original = new TextEncoder().encode('x');
    const compressed = arithmeticEncode(original, DEFAULT_FREQUENCIES);
    const decompressed = arithmeticDecode(compressed, DEFAULT_FREQUENCIES);

    expect(decompressed).toEqual(original);
  });

  it('produces smaller output than Huffman for long text', () => {
    const longText = new TextEncoder().encode(
      'The quick brown fox jumps over the lazy dog. '.repeat(20)
    );
    const arithCompressed = arithmeticEncode(longText, DEFAULT_FREQUENCIES);
    const huffmanCompressed = huffmanEncode(longText, DEFAULT_FREQUENCIES);

    // Arithmetic should produce smaller or equal output
    expect(arithCompressed.length).toBeLessThanOrEqual(
      huffmanCompressed.length + 5
    );
  });

  it('compressPayload uses arithmetic for long text', () => {
    const longText = new TextEncoder().encode(
      'The quick brown fox jumps over the lazy dog. '.repeat(20)
    );

    const [compressed, compressionType] = compressPayload(
      longText,
      DEFAULT_FREQUENCIES
    );

    expect(compressionType).toBe(COMPRESSION_ARITHMETIC);
    expect(compressed.length).toBeLessThan(longText.length);
  });

  it('decompressPayload handles arithmetic compression', () => {
    const original = new TextEncoder().encode('Test arithmetic compression');
    const compressed = arithmeticEncode(original, DEFAULT_FREQUENCIES);

    const decompressed = decompressPayload(
      compressed,
      COMPRESSION_ARITHMETIC,
      DEFAULT_FREQUENCIES
    );

    expect(decompressed).toEqual(original);
  });
});

describe('Cross-compatibility: Full Stego', () => {
  let stegoRoundtrip: StegoRoundtrip | null;

  beforeAll(() => {
    stegoRoundtrip = loadFixture<StegoRoundtrip>('stego_roundtrip.json');
  });

  it('decodes Python-encoded cover text', async () => {
    if (!stegoRoundtrip) {
      console.warn('Skipping: stego_roundtrip.json not found');
      return;
    }

    const client = new FixedDistributionClient(32);

    for (const testCase of stegoRoundtrip.encoded) {
      const secret = await decryptSecretBlob(testCase.secret_blob, testCase.password);
      const expectedMessage = base64ToBytes(testCase.expected_message);

      const decoded = await decodeMessage(
        testCase.cover_text,
        secret,
        client,
        testCase.prompt
      );

      expect(decoded).toEqual(expectedMessage);
    }
  });

  it('encodes and decodes back to original message', async () => {
    if (!stegoRoundtrip) return;

    const client = new FixedDistributionClient(32);

    for (const testCase of stegoRoundtrip.encoded) {
      const secret = await decryptSecretBlob(testCase.secret_blob, testCase.password);
      const originalMessage = base64ToBytes(testCase.expected_message);

      // Encode in TypeScript (will produce different cover text due to random nonces)
      const coverText = await encodeMessage(
        originalMessage,
        secret,
        client,
        testCase.prompt,
        true // compress
      );

      // Decode it back - this should produce the original message
      const decoded = await decodeMessage(coverText, secret, client, testCase.prompt);

      expect(decoded).toEqual(originalMessage);
    }
  });
});

describe('FixedDistributionClient', () => {
  it('returns deterministic distribution', async () => {
    const client = new FixedDistributionClient(32);

    const dist1 = await client.getTokenDistribution('context 1');
    const dist2 = await client.getTokenDistribution('context 2');

    expect(dist1).toEqual(dist2);
    expect(dist1.length).toBe(32);
  });

  it('matches Python FixedDistributionClient values', async () => {
    const client = new FixedDistributionClient(32);
    const dist = await client.getTokenDistribution('any context');

    // Verify exact values match Python
    expect(dist[0]).toEqual({ token: ' the', prob: 0.12 });
    expect(dist[1]).toEqual({ token: ' a', prob: 0.10 });
    expect(dist[2]).toEqual({ token: ' to', prob: 0.08 });
  });

  it('respects vocab size limit', async () => {
    const client16 = new FixedDistributionClient(16);
    const client8 = new FixedDistributionClient(8);

    const dist16 = await client16.getTokenDistribution('test');
    const dist8 = await client8.getTokenDistribution('test');

    expect(dist16.length).toBe(16);
    expect(dist8.length).toBe(8);
  });
});

describe('Secret Blob Compression', () => {
  it('generates secrets with null huffman_freq by default', () => {
    const secret = generateSecret({ k: 16 });
    expect(secret.huffman_freq).toBeNull();
  });

  it('stores custom frequencies when provided', () => {
    const secret = generateSecret({
      k: 16,
      huffmanSample: new TextEncoder().encode('custom sample text'),
    });
    expect(secret.huffman_freq).not.toBeNull();
    expect(typeof secret.huffman_freq).toBe('object');
  });

  it('roundtrips secrets with null huffman_freq', async () => {
    const secret = generateSecret({ k: 16, knock: [1, 2, 3, 4, 5, 6] });
    const password = 'test123';

    const encrypted = await encryptSecretBlob(secret, password);
    const decrypted = await decryptSecretBlob(encrypted, password);

    expect(decrypted.huffman_freq).toBeNull();
    expect(decrypted.k).toBe(16);
    expect(decrypted.knock).toEqual([1, 2, 3, 4, 5, 6]);
  });

  it('produces compressed blobs that are smaller than uncompressed', async () => {
    const secret = generateSecret({ k: 16 });
    const password = 'test123';

    const encrypted = await encryptSecretBlob(secret, password);

    // With null huffman_freq + zlib compression, blob should be ~300-400 chars
    expect(encrypted.length).toBeLessThan(500);
  });

  it('encode/decode works with null huffman_freq secret', async () => {
    const client = new FixedDistributionClient(32);
    const secret = generateSecret({
      k: 16,
      knock: [0, 1, 2, 3, 4, 5],
      preambleTokens: 5,
      suffixTokens: 5,
    });

    expect(secret.huffman_freq).toBeNull();

    const message = new TextEncoder().encode('Test with null frequencies');
    const prompt = 'Test: ';

    const coverText = await encodeMessage(message, secret, client, prompt, true);
    const decoded = await decodeMessage(coverText, secret, client, prompt);

    expect(decoded).toEqual(message);
  });

  it('decrypts Python-generated compressed blobs', async () => {
    // Load Python-generated compressed fixtures
    const path = join(__dirname, '../../tests/fixtures/secret_blobs_py_compressed.json');
    if (!existsSync(path)) {
      console.warn('Skipping: secret_blobs_py_compressed.json not found');
      return;
    }

    const pyBlobs = JSON.parse(readFileSync(path, 'utf-8'));

    for (const blob of pyBlobs.blobs) {
      const secret = await decryptSecretBlob(blob.encrypted, blob.password);

      expect(secret.version).toBe(blob.expected.version);
      expect(secret.k).toBe(blob.expected.k);
      expect(secret.knock).toEqual(blob.expected.knock);
      expect(secret.preamble_tokens).toBe(blob.expected.preamble_tokens);
      expect(secret.suffix_tokens).toBe(blob.expected.suffix_tokens);
      expect(secret.temperature).toBeCloseTo(blob.expected.temperature, 3);

      // huffman_freq should be null (Python compressed format uses None)
      if (blob.expected.huffman_freq_is_none) {
        expect(secret.huffman_freq).toBeNull();
      }
    }
  });
});

describe('System Prompt Feature', () => {
  it('generates secrets with system_prompt', () => {
    const systemPrompt = 'You are a weather bot. Write a weather report:\n\n';
    const secret = generateSecret({
      k: 16,
      systemPrompt,
    });

    expect(secret.system_prompt).toBe(systemPrompt);
  });

  it('defaults system_prompt to empty string', () => {
    const secret = generateSecret({ k: 16 });
    expect(secret.system_prompt).toBe('');
  });

  it('encodes and decodes with system_prompt', async () => {
    const client = new FixedDistributionClient(32);
    const systemPrompt = 'You are a helpful assistant.\n\n';
    const secret = generateSecret({
      k: 16,
      knock: [0, 1, 2, 3, 4, 5],
      preambleTokens: 5,
      suffixTokens: 5,
      systemPrompt,
    });

    const message = new TextEncoder().encode('Secret message with system prompt');
    const prompt = 'Test: ';

    const coverText = await encodeMessage(message, secret, client, prompt, true);
    const decoded = await decodeMessage(coverText, secret, client, prompt);

    expect(decoded).toEqual(message);
  });

  it('cover text does not contain system_prompt', async () => {
    const client = new FixedDistributionClient(32);
    const systemPrompt = 'HIDDEN SYSTEM PROMPT - THIS SHOULD NOT APPEAR';
    const secret = generateSecret({
      k: 16,
      knock: [0, 1, 2, 3, 4, 5],
      preambleTokens: 5,
      suffixTokens: 5,
      systemPrompt,
    });

    const message = new TextEncoder().encode('Test');
    const prompt = 'Visible prompt: ';

    const coverText = await encodeMessage(message, secret, client, prompt, true);

    // Cover text should start with the user prompt, not system_prompt
    expect(coverText.startsWith(prompt)).toBe(true);
    expect(coverText.includes(systemPrompt)).toBe(false);
  });

  it('handles secrets without system_prompt (backwards compatibility)', async () => {
    const client = new FixedDistributionClient(32);
    const secret = generateSecret({
      k: 16,
      knock: [0, 1, 2, 3, 4, 5],
      preambleTokens: 5,
      suffixTokens: 5,
    });

    // Simulate old secret without system_prompt field
    delete (secret as any).system_prompt;

    const message = new TextEncoder().encode('Test backwards compat');
    const prompt = 'Test: ';

    const coverText = await encodeMessage(message, secret, client, prompt, true);
    const decoded = await decodeMessage(coverText, secret, client, prompt);

    expect(decoded).toEqual(message);
  });

  it('roundtrips secret with system_prompt through encrypt/decrypt', async () => {
    const systemPrompt = 'System prompt for testing\n';
    const secret = generateSecret({
      k: 16,
      knock: [1, 2, 3, 4, 5, 6],
      systemPrompt,
    });
    const password = 'test123';

    const encrypted = await encryptSecretBlob(secret, password);
    const decrypted = await decryptSecretBlob(encrypted, password);

    expect(decrypted.system_prompt).toBe(systemPrompt);
  });
});

describe('TypeScript Roundtrip with FixedDistributionClient', () => {
  it('encodes and decodes correctly', async () => {
    const client = new FixedDistributionClient(32);
    const secret = generateSecret({
      k: 16,
      knock: [0, 1, 2, 3, 4, 5],
      preambleTokens: 5,
      suffixTokens: 5,
    });

    const message = new TextEncoder().encode('Hello from TypeScript!');
    const prompt = 'Test: ';

    const coverText = await encodeMessage(message, secret, client, prompt, true);
    const decoded = await decodeMessage(coverText, secret, client, prompt);

    expect(decoded).toEqual(message);
  });

  it('handles empty message', async () => {
    const client = new FixedDistributionClient(32);
    const secret = generateSecret({
      k: 16,
      knock: [0, 1, 2, 3, 4, 5],
      preambleTokens: 5,
      suffixTokens: 5,
    });

    const message = new Uint8Array(0);
    const prompt = 'Test: ';

    const coverText = await encodeMessage(message, secret, client, prompt, true);
    const decoded = await decodeMessage(coverText, secret, client, prompt);

    expect(decoded).toEqual(message);
  });

  it('handles binary data', async () => {
    const client = new FixedDistributionClient(32);
    const secret = generateSecret({
      k: 16,
      knock: [0, 1, 2, 3, 4, 5],
      preambleTokens: 5,
      suffixTokens: 5,
    });

    // Create binary data with all byte values
    const message = new Uint8Array(256);
    for (let i = 0; i < 256; i++) {
      message[i] = i;
    }
    const prompt = 'Test: ';

    const coverText = await encodeMessage(message, secret, client, prompt, false);
    const decoded = await decodeMessage(coverText, secret, client, prompt);

    expect(decoded).toEqual(message);
  });
});
